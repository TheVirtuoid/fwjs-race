<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Fun with JavaScript - Track POC</title>

		<!-- Babylon.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
<!--
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
-->
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<!-- Virtuoid -->
		<script src="/js/track-poc.js"></script>

		<style>
			html, body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}

			#track-selector {
				border: 2px solid blue;
				border-radius: 1rem;
				background-color: white;
				padding: .5rem 1rem;
				color: black;
				position: absolute;
				top: 1rem;
				left: 1rem;
			}

			#track-error {
				border: 2px solid blue;
				border-radius: 1rem;
				background-color: white;
				padding: .5rem 1rem;
				color: black;
				display: none;
				position: absolute;
				top: 50%;
				left: 50%;
				margin-right: -50%;
				transform: translate(-50%, -50%);
			}
		</style>
	</head>
<body>
	<div id="track-selector">
		<label for="tracks">Choose a track:</label>
		<select id="trackFamilies"></select>
		<select id="trackMembers"></select>
		<button type="button" id="go">GO!</button>
	</div>
	<div id="track-renderer">
		<canvas id="renderCanvas"></canvas>
	</div>
	<div id="track-error">
		<h1>Error</h1>
		<p id="track-error-text"></p>
	</div>
	<script>

		//======================================================================
		// TRACK SELECTION

		const displayMgr = {
			clearError: function() {
				this._trackError.style.display = "none";
			},

			showError: function(e) {
				this._trackError.style.display = "block";
				this._trackErrorText.innerText = e.toString();
			},

			init: function() {
				this._trackError = document.getElementById("track-error");
				this._trackErrorText = document.getElementById("track-error-text");
			},
		}

		//======================================================================
		// TRACK SELECTION

		const familySelector = document.getElementById("trackFamilies");
		const memberSelector = document.getElementById("trackMembers");

		familySelector.addEventListener("change", () => {
			tracks.onFamilyChanged(familySelector, memberSelector);
		});
		memberSelector.addEventListener("change", () => {
			tracks.createMesh(memberSelector);
		});

		//======================================================================
		// TRACK DEFINITIONS

		const posX = new BABYLON.Vector3.Right;
		const negX = new BABYLON.Vector3.Left;
		const posY = new BABYLON.Vector3.Up;
		const negY = new BABYLON.Vector3.Down;
		const posZ = new BABYLON.Vector3.Forward;
		const negZ = new BABYLON.Vector3.Backward;
		const zero = { x:0, y:0, z:0 };

		const tracks = {

			createMesh: function(selector) {

				for (let mesh of this._meshes) {
					scene.removeMesh(mesh);
					mesh.dispose();
				}
				this._meshes.length = 0;

				try {
					const key = selector.value;
					const track = this._tracks[key];
					const settings = this._options[key] ? this._options[key] : {};

					const ribbons = TrackPOC.build(track, (u) => { return new BABYLON.Vector3(u.x, u.y, u.z); }, settings);
					for (let i = 0; i < ribbons.length; i++) {
						const mesh = BABYLON.MeshBuilder.CreateRibbon(
								`Segment${i}`,
								{
									pathArray: ribbons[i],
									sideOrientation: BABYLON.Mesh.DOUBLESIDE,
									closePath: track.closed,
								},
								scene);
						mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0 }, scene);
						this._meshes.push(mesh);
					}
					displayMgr.clearError();
				} catch (e) {
					displayMgr.showError(e);
				}
			},
			onFamilyChanged: function(familySelector, memberSelector) {
				const key = familySelector.value;
				let firstMatch = -1;
				for (let i = 0; i < memberSelector.options.length; i++) {
					const option = memberSelector.options[i];
					const match = option.getAttribute("family") === key;
					option.style.display = match ? "block" : "none";
					if (match && firstMatch === -1) firstMatch = i;
				}
				if (firstMatch !== -1) memberSelector.selectedIndex = firstMatch;
				this.createMesh(memberSelector);
			},
			register: function(track) {

				// Invoke function if not an object
				if (typeof(track) === 'function') track = track();

				// Perform late initialization
				if (track.init) track.init();

				// Get the family
				if (!track.family && !track.sibling) throw "A track must define either 'family' or 'sibling'";
				if ((track.family || track.sibling) && (track.name || track.desc)) throw "A track defining 'family' or 'sibling' cannot define 'name' or 'desc'";
				if (track.sibling && !track.sibling.family) throw `A 'sibling' track, here '${track.sibling}', must define 'family'`;
				const family = track.family ? track.family : track.sibling.family;
				const familyKey = this._removeSpaces(family);

				// Get the member
				if (track.sibling && !track.member) throw "A track defining 'sibling' must also define 'member'";
				if (track.sibling && track.member && track.member === this._originalMember) {
					throw `A track defining 'sibling' cannot have 'member' set to '${this._originalMember}'`;
				}
				const member = track.member ? track.member : this._originalMember;
				const memberKey = familyKey + this._removeSpaces(member);
				const key = familyKey + memberKey;

				// Add family if necessary
				if (!this._families[familyKey]) {
					// This possibly leads to multiple member lists to avoid
					// altering the 'display' style in onFamilyChanged
					this._families[familyKey] = [];

					// Add the family to the family list
					const fsOption = document.createElement("option");
					fsOption.setAttribute('value', familyKey);
					fsOption.innerHTML = family;
					familySelector.appendChild(fsOption);
				}

				// Add to member selector
				const msOption = document.createElement("option");
				msOption.setAttribute('value', key);
				msOption.setAttribute('family', familyKey);
				msOption.innerHTML = member;
				memberSelector.appendChild(msOption);

				// Add the track to the tracks and options arrays
				this._tracks[key] = track.track;
				if (track.options) this._options[key] = track.options;

				return track;
			},

			_families: {},
			_meshes: [],
			_options: {},
			_originalMember: 'Original',
			_removeSpaces: function(value) { return value.replace(/\s/g, ''); },
			_tracks: {},
		};

		const defineTracks = function() {

			// See https://spencermortensen.com/articles/bezier-circle/
			// If we want a closer approximation, we would need to break the
			// convention that backward = -forward and allow backward to be
			// forward rotated 180 degrees around down.
			const circleWeight = 0.5519150244935105707435627;

			//----------------------------------------------------------------------
			// Closed ovals

			const track0 = tracks.register({
				family: 'Closed oval',
				points: [
					{ center: new BABYLON.Vector3(2, 0, 0), forward: posZ },	// Start position
					{ center: new BABYLON.Vector3(2, 0, 4), forward: posZ },
					{ center: new BABYLON.Vector3(0, 0, 6), forward: negX },
					{ center: new BABYLON.Vector3(-2, 0, 4), forward: negZ },
					{ center: new BABYLON.Vector3(-2, 0, -4), forward: negZ },
					{ center: new BABYLON.Vector3(0, 0, -6), forward: posX },
					{ center: new BABYLON.Vector3(2, 0, -4), forward: posZ },
				],
				track: { closed: true },
				options: {
					backwardWeight: 0.5,
					forwardWeight: 0.5,
					trackWidth: 0.5,
				},
				init: function() {
					this.track.segments = [ { points: this.points } ];
				}
			});
			tracks.register({
				sibling: track0,
				member: 'Variable wall height',
				options: track0.options,
				track: {
					closed: true,
					segments: [
						{
							points: [
								track0.points[0],
								{ center: track0.points[1].center, forward: track0.points[1].forward, wallHeight: .6 },
								{ center: track0.points[2].center, forward: track0.points[2].forward, wallHeight: .7 },
								{ center: track0.points[3].center, forward: track0.points[3].forward, wallHeight: .6 },
								track0.points[4],
								track0.points[5],
								track0.points[6],
							],
						},
					],
				},
			});

			//----------------------------------------------------------------------
			// Common launch and jump points

			const launch = {
				start: {
					center: { x:10 , y:5, z:0 }
				},
				end: {
					center: { x:9, y:4.9, z:0 },
				},

				init: function() {
					this.start.forward = {
						x: this.end.center.x - this.start.center.x,
						y: this.end.center.y - this.start.center.y,
						z: this.end.center.z - this.start.center.z,
					};
					this.end.forward = this.start.forward;
					this.straight = {
						type: 'straight',
						endsAt: this.end.center,
						startsAt: this.start.center,
						forwardWeight: 1.1
					};
				},
			}
			launch.init();

			const jump = {
				descent: 1,
				launchSegment: {
					points: [
						launch.straight,
						{
							center: { x:.5, y:1, z:0 },
							forward: negX,
							backwardWeight: 4,
						},
					],
				},
				radius: 2,

				_catchDrop: .1,
				_gap: 1,

				init: function() {
					const launchEnd = this.launchSegment.points[this.launchSegment.points.length - 1];
					this.catchStart = {
						center: {
							x: launchEnd.center.x - this._gap,
							y: launchEnd.center.y - this._catchDrop,
							z: launchEnd.center.z,
						},
						forward: negX,
					}
					this.catchEnd = {
						center: {
							x: this.catchStart.center.x - this.radius + this._gap / 2,
							y: this.catchStart.center.y - this.descent / 4,
							z: this.catchStart.center.z
						},
						forward: negX,
					}
					this.runout = {
						type: 'straight',
						length: 2 * this.radius,
					}
				},
			}
			jump.init();

			const parametricBank = [
				{ t:0, v:10 },
				{ t:1/3, v:23 },
				{ t:2/3, v:23 },
				{ t:1, v:10 },
			]

			//----------------------------------------------------------------------
			// Simple slope

			const track1 = tracks.register({
				family: "Simple slope",
				runoutStart: {
					center: zero,
					forward: negX,
					backwardWeight: 4,
				},
				runoutStraight: {
					type: 'straight',
					length: 2,
				},

				init: function() {
					this.track = {
						segments: [
							{
								points: [
									launch.start,
									launch.end,
									this.runoutStart,
									this.runoutStraight,
								],
							}
						],
					};
				}
			});
			const track1a = tracks.register({
				sibling: track1,
				member: 'Variable track width',
				runoutStraight: {
					type: 'straight',
					length: track1.runoutStraight.length,
					trackWidth: 2,
				},

				init: function() {
					this.track = {
						segments: [
							{
								points: [
									launch.start,
									launch.straight,
									track1.runoutStart,
									this.runoutStraight,
								],
							},
						],
					}
				},
			});
			tracks.register({
				sibling: track1,
				member: "Alternate straight",
				track: {
					segments: [
						{
							points: [
								{
									type: 'straight',
									startsAt: launch.end.center,
									forward: launch.end.forward,
									length: 1.004987562112089,
									forwardWeight: 1.1
								},
								track1.runoutStart,
								track1a.runoutStraight,
							],
						},
					],
				},
			});

			//----------------------------------------------------------------------
			// Left turn ramp

			const track2 = tracks.register({
				family: "Left turn ramp",

				curveEnd: {
					backwardWeight: circleWeight * jump.radius,
					forward: posZ,
				},
				curveLeft: {
					backwardWeight: circleWeight * jump.radius,
					forward: posX,
					forwardWeight: circleWeight * jump.radius,
				},
				curveStart: {
					center: jump.catchEnd.center,
					forward: jump.catchEnd.forward,
					forwardWeight: circleWeight * jump.radius,
				},
				curveTop: {
					backwardWeight: circleWeight * jump.radius,
					forward: negZ,
					forwardWeight: circleWeight * jump.radius,
				},

				init: function() {
					this.curveTop.center = {
						x: this.curveStart.center.x - jump.radius,
						y: this.curveStart.center.y - jump.descent / 4,
						z: this.curveStart.center.z - jump.radius,
					}
					this.curveLeft.center = {
						x: this.curveTop.center.x + jump.radius,
						y: this.curveTop.center.y - jump.descent / 4,
						z: this.curveTop.center.z - jump.radius
					}
					this.curveEnd.center = {
						x: this.curveLeft.center.x + jump.radius,
						y: this.curveLeft.center.y - jump.descent / 4,
						z: this.curveLeft.center.z + jump.radius
					}
					this.track = {
						segments: [
							jump.launchSegment,
							{
								points: [
									jump.catchStart,
									this.curveStart,
									this.curveTop,
									this.curveLeft,
									this.curveEnd,
									jump.runout,
								],
							},
						],
					}
				},
			});
			tracks.register({
				sibling: track2,
				member: "45&#176; bank",
				track: {
					segments: [ jump.launchSegment, {
						points: [
							jump.catchStart,
							{
								center: track2.curveStart.center,
								forward: track2.curveStart.forward,
								forwardWeight: track2.curveStart.forwardWeight,
								trackBank: 10,
							},
							{
								backwardWeight: track2.curveTop.backwardWeight,
								center: track2.curveTop.center,
								forward: track2.curveTop.forward,
								forwardWeight: track2.curveTop.forwardWeight,
								trackBank: 45,
							},
							{
								backwardWeight: track2.curveLeft.backwardWeight,
								center: track2.curveLeft.center,
								forward: track2.curveLeft.forward,
								forwardWeight: track2.curveLeft.forwardWeight,
								trackBank: 45,
							},
							{
								backwardWeight: track2.curveEnd.backwardWeight,
								center: track2.curveEnd.center,
								forward: track2.curveEnd.forward,
								trackBank: 10,
							},
							jump.runout
						],
					}],
				},
			});
			tracks.register({
				sibling: track2,
				member: "Using spiral",
				track: {
					segments: [ jump.launchSegment, {
						points: [
							jump.catchStart,
							jump.catchEnd,
							{
								type: 'spiral',
								endsAt: {
									center: track2.curveEnd.center,
									forward: track2.curveEnd.forward,
								},
								rotate: 'left',
							},
							jump.runout
						],
					}],
				},
			});
			tracks.register({
				sibling: track2,
				member: "Using spiral with 23&#176; bank",
				track: {
					segments: [ jump.launchSegment, {
						points: [
							jump.catchStart,
							jump.catchEnd,
							{
								type: 'spiral',
								endsAt: {
									center: track2.curveEnd.center,
									forward: track2.curveEnd.forward,
								},
								rotate: 'left',
								trackBank: parametricBank,
							},
							jump.runout
						],
					}],
				},
			});

			//----------------------------------------------------------------------
			// Right turn ramp

			const track3 = tracks.register({
				family: "Right turn ramp",

				curveEnd: {
					backwardWeight: circleWeight * jump.radius,
					forward: negZ,
				},
				curveRight: {
					backwardWeight: circleWeight * jump.radius,
					forward: posX,
					forwardWeight: circleWeight * jump.radius,
				},
				curveStart: track2.curveStart,
				curveTop: {
					backwardWeight: circleWeight * jump.radius,
					forward: posZ,
					forwardWeight: circleWeight * jump.radius,
				},

				init: function() {
					this.curveTop.center = {
						x: this.curveStart.center.x - jump.radius,
						y: this.curveStart.center.y - jump.descent / 4,
						z: this.curveStart.center.z + jump.radius,
					}
					this.curveRight.center = {
						x: this.curveTop.center.x + jump.radius,
						y: this.curveTop.center.y - jump.descent / 4,
						z: this.curveTop.center.z + jump.radius
					}
					this.curveEnd.center = {
						x: this.curveRight.center.x + jump.radius,
						y: this.curveRight.center.y - jump.descent / 4,
						z: this.curveRight.center.z - jump.radius
					}
					this.track = {
						segments: [
							jump.launchSegment,
							{
								points: [
									jump.catchStart,
									this.curveStart,
									this.curveTop,
									this.curveRight,
									this.curveEnd,
									jump.runout,
								],
							},
						],
					}
				},
			});
			tracks.register({
				sibling: track3,
				member: "45&#176; bank",
				track: { segments: [
					jump.launchSegment,
					{ points: [
						jump.catchStart,
						{
							center: track3.curveStart.center,
							forward: track3.curveStart.forward,
							forwardWeight: track3.curveStart.forwardWeight,
							trackBank: -10,
						},
						{
							backwardWeight: track3.curveTop.backwardWeight,
							center: track3.curveTop.center,
							forward: track3.curveTop.forward,
							forwardWeight: track3.curveTop.forwardWeight,
							trackBank: -45,
						},
						{
							backwardWeight: track3.curveRight.backwardWeight,
							center: track3.curveRight.center,
							forward: track3.curveRight.forward,
							forwardWeight: track3.curveRight.forwardWeight,
							trackBank: -45,
						},
						{
							backwardWeight: track3.curveEnd.backwardWeight,
							center: track3.curveEnd.center,
							forward: track3.curveEnd.forward,
							trackBank: -10,
						},
						jump.runout
					]},
				]},
			});
			tracks.register({
				sibling: track3,
				member: "Using spiral",
				track: {
					segments: [ jump.launchSegment, {
						points: [
							jump.catchStart,
							jump.catchEnd,
							{
								type: 'spiral',
								endsAt: {
									center: track3.curveEnd.center,
									forward: track3.curveEnd.forward,
								},
								rotate: 'right',
							},
							jump.runout
						],
					}],
				},
			});
			tracks.register({
				sibling: track3,
				member: "Using spiral with 23&#176; bank",
				track: {
					segments: [ jump.launchSegment, {
						points: [
							jump.catchStart,
							jump.catchEnd,
							{
								type: 'spiral',
								endsAt: {
									center: track3.curveEnd.center,
									forward: track3.curveEnd.forward,
								},
								rotate: 'right',
								trackBank: parametricBank,
							},
							jump.runout
						],
					}],
				},
			});

			//----------------------------------------------------------------------
			// Loop

			tracks.register({
				family: "Loop",

				_offset: .4,
				_radius: 3,

				init: function() {
					const weight = circleWeight * this._radius;

					this.track = { segments: [ { points: [
						launch.start,
						launch.end,
					]}]};
					let p = this._pushPoint({	// End of slope, start of flat
						center: zero,
						forward: negX,
						backwardWeight: 4,
					});
					p = this._pushPoint({		// Entry into loop
						center: {
							x: p.center.x - this._radius,
							y: p.center.y,
							z: p.center.z
						},
						forward: negX,
						forwardWeight: weight,
					});
					p = this._pushPoint({		// First quarter of loop
						backwardWeight: weight,
						center: {
							x: p.center.x - this._radius,
							y: p.center.y + this._radius,
							z: p.center.z + this._offset,
						},
						forward: posY,
						forwardWeight: weight,
						trackBank: negX,
					});
					p = this._pushPoint({		// Top of loop
						backwardWeight: weight,
						center: {
							x: p.center.x + this._radius,
							y: p.center.y + this._radius,
							z: p.center.z + this._offset
						},
						forward: posX,
						forwardWeight: weight,
						trackBank: posY,
					});
					p = this._pushPoint({		// Last quarter of loop
						backwardWeight: weight,
						center: {
							x: p.center.x + this._radius,
							y: p.center.y - this._radius,
							z: p.center.z + this._offset
						},
						forward: negY,
						forwardWeight: weight,
						trackBank: posX,
					});
					p = this._pushPoint({		// Exit of loop
						backwardWeight: weight,
						center: {
							x: p.center.x - this._radius,
							y: p.center.y - this._radius,
							z: p.center.z + this._offset
						},
						forward: negX,
					});
					this._pushPoint({			// Runout
						type: 'straight',
						length: 2 * this._radius,
					});
				},

				_pushPoint: function(p) {
					this.track.segments[0].points.push(p);
					return p;
				},
			});

			//----------------------------------------------------------------------
			// Flat curves

			const track5 = tracks.register({
				family: "Flat curves",

				heights: [0, 2, 4],
				runoutLength: 1,

				_radius: 4,

				createPoint: function(segment, vertex, forward, weightsToSet) {
					const p = {
						center: {
							x: this._vertices[vertex].x,
							y: this.heights[segment],
							z: this._vertices[vertex].z
						},
						forward: forward
					};
					if (weightsToSet) {
						for (let key of weightsToSet) p[key] = this._weight;
					}
					return p;
				},
				pushPoint: function(segments, segment, vertex, forward, weightsToSet) {
					const p = typeof(vertex) === 'number' ?
						this.createPoint(segment, vertex, forward, weightsToSet) :
						vertex;
					segments[segment].points.push(p);
					return p;
				},

				init: function() {
					this._weight = this._radius * circleWeight;

					this._vertices = [];
					let v = this._pushVertex(this._radius, -this.runoutLength);
					v = this._pushVertex(v.x, v.z + this.runoutLength);
					v = this._pushVertex(v.x - this._radius, v.z + this._radius);
					v = this._pushVertex(v.x - this._radius, v.z - this._radius);
					this._pushVertex(v.x, v.z - this.runoutLength);

					const segments = [ { points: [] }, { points: [] } ];
					this.track = { segments: segments  };

					// Segment 0, left turn
					this.pushPoint(segments, 0, 0, posZ);
					this.pushPoint(segments, 0, 1, posZ, ['forwardWeight']);
					this.pushPoint(segments, 0, 2, negX, ['backwardWeight', 'forwardWeight']);
					this.pushPoint(segments, 0, 3, negZ, ['backwardWeight']);
					this.pushPoint(segments, 0, 4, negZ);

					// Segment 1, right turn
					this.pushPoint(segments, 1, 4, posZ);
					this.pushPoint(segments, 1, 3, posZ, ['forwardWeight']);
					this.pushPoint(segments, 1, 2, posX, ['backwardWeight', 'forwardWeight']);
					this.pushPoint(segments, 1, 1, negZ, ['backwardWeight']);
					this.pushPoint(segments, 1, 0, negZ);
				},

				_pushVertex: function(x, z) {
					const v = { x: x, z: z };
					this._vertices.push(v);
					return v;
				},
			});
			tracks.register({
				sibling: track5,
				member: "With spirals",

				init: function() {

					const runout = { type: 'straight', length: track5.runoutLength };

					const segments = [ track5.track.segments[0], { points: [] }, { points: [] } ];
					this.track = { segments: segments }

					// Segment 1, left spiral
					track5.pushPoint(segments, 1, 0, posZ);
					track5.pushPoint(segments, 1, runout);
					track5.pushPoint(segments, 1, {
						type: 'spiral',
						endsAt: track5.createPoint(1, 3, negZ),
						rotate: 'left',
					});
					track5.pushPoint(segments, 1, runout);

					// Segment 2, right spiral
					track5.pushPoint(segments, 2, 4, posZ);
					track5.pushPoint(segments, 2, runout);
					track5.pushPoint(segments, 2, {
						type: 'spiral',
						endsAt: track5.createPoint(2, 1, negZ),
						rotate: 'right',
					});
					track5.pushPoint(segments, 2, runout);
				},
			});

			//----------------------------------------------------------------------
			// Helixes

			const track6 = tracks.register({
				family: 'Helix',
				track: { segments: [ { points: [
					{
						type: 'error',
					},
				]}]},
			});
		}();

		//======================================================================
		// BABYLON IMPLEMENTATION

		const canvas = document.getElementById("renderCanvas");

		const startRenderLoop = function (engine, canvas) {
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					sceneToRender.render();
				}
			});
		}

		//	It is not clear why 'engine' and 'scene' must be declared as 'var'
		//	instead of 'let'. The page throws a 'engine is null' exception if
		//	'engine' is declared 'let' and does not display anything if 'scene'
		//	is declared 'let', presumably becasue 'scene' is null when
		//	sceneToRender is set.
		var engine = null;
		var scene = null;
		let sceneToRender = null;

		const createDefaultEngine = function() {
			return new BABYLON.Engine(canvas, true, {
				preserveDrawingBuffer: true,
				stencil: true,
				disableWebGL2Support: false
			});
		};

		const createScene = function () {
			const scene = new BABYLON.Scene(engine);

			const camera = new BABYLON.ArcRotateCamera(
				"Camera",
				3 * Math.PI / 2,
				3 * Math.PI / 8,
				30,
				BABYLON.Vector3.Zero());
			camera.attachControl(canvas, true);
			const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 50, 0));

			scene.enablePhysics(new BABYLON.Vector3(0, -8.91, 0), new BABYLON.AmmoJSPlugin());

			return scene;
		}

		window.initFunction = async function() {

			displayMgr.init();

			const asyncEngineCreation = async function() {
				try {
					return createDefaultEngine();
				} catch(e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			if (!engine) throw 'engine should not be null.';

			await Ammo();

			startRenderLoop(engine, canvas);

			window.scene = createScene();
			tracks.onFamilyChanged(familySelector, memberSelector);
		};

		initFunction().then(() => {
			sceneToRender = scene
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});

		// testing on track 2
		const ballDiameter = .25;
		const ballWeight = 2;
		let ball;
		const dropTheBall = () => {

			if (ball) scene.removeMesh(ball);
			ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: ballDiameter }, scene);
			ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, {mass: ballWeight}, scene);

			const track = tracks._tracks[trackSelector.value];
			const segment = track.segments[0];
			const p0 = segment.points[0].center;
			const p1 = segment.points[1].center;

			const t = .8;
			const olt = 1 - t;
			const altitude = 1;
			ball.position.x = p0.x * t + p1.x * olt;
			ball.position.y = p0.y * t + p0.y * olt + altitude;	// Force the ball above the track
			ball.position.z = p0.z * t + p1.z * olt;
		};

		document.getElementById('go').addEventListener('click', dropTheBall);

	</script>
</body>
</html>
