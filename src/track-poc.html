<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Babylon.js sample code</title>

		<!-- Babylon.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
<!--
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
-->
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<!-- Virtuoid -->
		<script src="/js/track-poc.js"></script>

		<style>
			html, body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
		</style>
	</head>
<body>
	<div>
		<label for="tracks">Choose a track:</label>
		<select name="tracks" id="tracks">
			<option value="track0">Track 0 (closed oval)</option>
			<option value="track0a">Track 0a (track 0 with variable wall height)</option>
			<option value="track1">Track 1 (single ramp)</option>
			<option value="track1a">Track 1a (track 1 with variable track width)</option>
			<option value="track1b">Track 1b (track 1a with alternate straight)</option>
			<option value="track2">Track 2 (ramp with jump and left curve)</option>
			<option value="track2a">Track 2a (track 2 with 45&#176; bank)</option>
			<!--option value="track2b">Track 2b (track 2 using spiral)</option-->
			<option value="track3">Track 3 (ramp with jump and right curve)</option>
			<option value="track3a">Track 3a (track 3 with 45&#176; bank)</option>
			<option value="track4">Track 4 (loop)</option>
			<option value="track5">Track 5 (flat 180&#176; turns)</option>
			<option value="track5a">Track 5a (track 5 using spiral)</option>
		</select>
		<button type="button" id="go">GO!</button>
	</div>
	<div>
		<canvas id="renderCanvas"></canvas>
	</div>
	<script>


		//======================================================================
		// TRACK SELECTION
		const trackSelector = document.getElementById("tracks");
		trackSelector.addEventListener("change", () => {
			createMesh();
		});

		//======================================================================
		// TRACK DEFINITIONS

		// Nomenclature
		//
		// All track variables start with 'tm' denoting 'track #m'.
		//
		// A one or two letter abbreviate follows describing the type of
		// The table below defines these. These are defined in relationship to
		// one or a series of end points.
		//
		// A reference to a single end point uses the letter 'n'.
		//
		// A reference to a range of end points uses the form 'n_o' which
		// refers to the end points n, n+1, ... o.
		//
		//	c	tmcn	a Bezier curve end point's center vector
		//	ep	tmepn	a Bezier curve end point
		//	s	tmsn_o	a segment (Bezier cubic curve)
		//	t	tmtn_o	a tangent

		const tracks = {};
		const options = {};

		const posX = new BABYLON.Vector3.Right;
		const negX = new BABYLON.Vector3.Left;
		const posY = new BABYLON.Vector3.Up;
		const negY = new BABYLON.Vector3.Down;
		const posZ = new BABYLON.Vector3.Forward;
		const negZ = new BABYLON.Vector3.Backward;
		const zero = { x:0, y:0, z:0 };

		// See https://spencermortensen.com/articles/bezier-circle/
		// If we want a closer approximation, we would need to break the
		// convention that backward = -forward and allow backward to be
		// forward rotated 180 degrees around down.
		const circleWeight = 0.5519150244935105707435627;

		//----------------------------------------------------------------------
		// Track 0, the original demo track

		const trackWidth = 0.5;
		const cpDistance = 0.5;		// This is now the forward/backward weight

		const t0ds = {
			backwardWeight: cpDistance,
			forwardWeight: cpDistance,
			trackWidth: trackWidth,
		};

		// Note that the original implementation used 'closePath: true' when
		// creating the ribbon. The system does not do this so we manually
		// close the track by adding an extra segment.
		const t0s1 = {
			points: [
				{ center: new BABYLON.Vector3(2, 0, 0), forward: posZ },	// Start position
				{ center: new BABYLON.Vector3(2, 0, 4), forward: posZ },
				{ center: new BABYLON.Vector3(0, 0, 6), forward: negX },
				{ center: new BABYLON.Vector3(-2, 0, 4), forward: negZ },
				{ center: new BABYLON.Vector3(-2, 0, -4), forward: negZ },
				{ center: new BABYLON.Vector3(0, 0, -6), forward: posX },
				{ center: new BABYLON.Vector3(2, 0, -4), forward: posZ },
			],
		}

		tracks.track0 = {
			segments: [ t0s1 ],
			closed: true,
		}
		options.track0 = t0ds;

		//----------------------------------------------------------------------
		// Track 0a, track 0 with variable wall height

		const t0ads = {
			backwardWeight: cpDistance,
			forwardWeight: cpDistance,
			trackWidth: trackWidth,
		};

		// Note that the original implementation used 'closePath: true' when
		// creating the ribbon. The system does not do this so we manually
		// close the track by adding an extra segment.
		const t0as1 = {
			points: [
				{ center: new BABYLON.Vector3(2, 0, 0), forward: posZ },	// Start position
				{ center: new BABYLON.Vector3(2, 0, 4), forward: posZ, wallHeight: .6 },
				{ center: new BABYLON.Vector3(0, 0, 6), forward: negX, wallHeight: .7 },
				{ center: new BABYLON.Vector3(-2, 0, 4), forward: negZ, wallHeight: .6 },
				{ center: new BABYLON.Vector3(-2, 0, 0), forward: negZ },
				{ center: new BABYLON.Vector3(-2, 0, -4), forward: negZ },
				{ center: new BABYLON.Vector3(0, 0, -6), forward: posX },
				{ center: new BABYLON.Vector3(2, 0, -4), forward: posZ },
			],
		}

		tracks.track0a = {
			segments: [ t0as1 ],
			closed: true,
		}
		options.track0a = t0ads;

		//----------------------------------------------------------------------
		// Common launch points

		const lv1 = { x:10 , y:5, z:0 };
		const lv2 = { x:9, y:4.9, z:0 };
		const lt1_2 = TrackPOC.vector.direction(lv1, lv2);
		const lep1 = {	// Start of starting ramp
			center: lv1,
			forward: lt1_2,
		};
		const lep2 = {	// End of starting ramp, start of runout
			center: lv2,
			forward: lt1_2,
			forwardWeight: 1.1,
		};
		const launchStraight1 = {
			type: 'straight',
			endsAt: lv2,
			forwardWeight: 1.1
		};
		const launchStraight2 = {
			type: 'straight',
			endsAt: lv2,
			startsAt: lv1,
			forwardWeight: 1.1
		};
		// Straight with just length demonstrated elsewhere
		//const launchStraight3 = {
		//	type: 'straight',
		//	length: 1.004987562112089,
		//	forwardWeight: 1.1
		//};
		const launchStraight4 = {
			type: 'straight',
			startsAt: lv1,
			forward: lt1_2,
			length: 1.004987562112089,
			forwardWeight: 1.1
		};

		//----------------------------------------------------------------------
		// Track 1, a simple slope

		const t1ep3 = {	// End of slope, start of runout
			center: zero,
			forward: negX,
			backwardWeight: 4,
		};
		const t1ep4 = {	// End of runout flat
			type: 'straight',
			length: 2,
		};

		const t1s1 = {
			points: [ lep1, launchStraight1, t1ep3, t1ep4 ]
		};

		tracks.track1 = {
			segments: [ t1s1 ]
		};

		//----------------------------------------------------------------------
		// Track 1a, track 1 with variable track width

		const t1aep3 = {	// End of slope, start of runout
			center: zero,
			forward: negX,
			backwardWeight: 4,
		};
		const t1aep4 = {	// End of runout flat
			type: 'straight',
			length: 2,
			trackWidth: 2,
		};

		const t1as1 = {
			points: [ lep1, launchStraight2, t1aep3, t1aep4 ]
		};

		tracks.track1a = {
			segments: [ t1as1 ]
		};

		//----------------------------------------------------------------------
		// Track 1b, track 1a with alternate straight

		const t1bep3 = {	// End of slope, start of runout
			center: zero,
			forward: negX,
			backwardWeight: 4,
		};
		const t1bep4 = {	// End of runout flat
			type: 'straight',
			length: 2,
			trackWidth: 2,
		};

		const t1bs1 = {
			points: [ launchStraight4, t1bep3, t1bep4 ]
		};

		tracks.track1b = {
			segments: [ t1bs1 ]
		};

		//----------------------------------------------------------------------
		// Common jump ramp points

		const jrGap = 1;
		const jrRadius = 2;
		const jrCatchDrop = .1;
		const jrDescent = 1;

		const jrep3 = {
			center: { x:.5, y:1, z:0 },
			forward: negX,
			backwardWeight: 4,
		};

		const jrep4 = {	// Start of catch
			center: {
				x: jrep3.center.x - jrGap,
				y: jrep3.center.y - jrCatchDrop,
				z: jrep3.center.z,
			},
			forward: negX,
		};

		const jrv5 = {
			x: jrep4.center.x - jrRadius + jrGap / 2,
			y: jrep4.center.y - jrDescent / 4,
			z: jrep4.center.z
		};
		const jrt5 = negX;

		const jrs1 = {
			points: [ launchStraight2, jrep3 ]
		};

		//----------------------------------------------------------------------
		// Track 2, slope into a jump with a turn left looping underneath the jump

		// NOTE: This may need some adjustments on the curve to avoid bumps where
		// we specify the tangent to have no y component.

		const t2ep5 = {	// Start of curve
			center: jrv5,
			forward: jrt5,
			forwardWeight: circleWeight * jrRadius,
		};
		const t2ep6 = {	// Top of curve
			backwardWeight: circleWeight * jrRadius,
			center: {
				x: t2ep5.center.x - jrRadius,
				y: t2ep5.center.y - jrDescent / 4,
				z: t2ep5.center.z - jrRadius,
			},
			forward: negZ,
			forwardWeight: circleWeight * jrRadius,
		};
		const t2ep7 = {	// Left extent of curve
			backwardWeight: circleWeight * jrRadius,
			center: {
				x: t2ep6.center.x + jrRadius,
				y: t2ep6.center.y - jrDescent / 4,
				z: t2ep6.center.z - jrRadius
			},
			forward: posX,
			forwardWeight: circleWeight * jrRadius,
		};
		const t2ep8 = {	// End of curve
			backwardWeight: circleWeight * jrRadius,
			center: {
				x: t2ep7.center.x + jrRadius,
				y: t2ep7.center.y - jrDescent / 4,
				z: t2ep7.center.z + jrRadius
			},
			forward: posZ,
		};
		const t2ep9 = {	// Runout
			type: 'straight',
			length: 2 * jrRadius,
		};

		const t2s2 = {
			points: [ jrep4, t2ep5, t2ep6, t2ep7, t2ep8, t2ep9 ]
		};

		tracks.track2 = {
			segments: [ jrs1, t2s2 ]
		};

		//----------------------------------------------------------------------
		// Track 2a, track 2 with bank

		const t2aep5 = {	// Start of curve
			center: t2ep5.center,
			forward: t2ep5.forward,
			forwardWeight: t2ep5.forwardWeight,
			trackBank: 10,
		};
		const t2aep6 = {	// Top of curve
			backwardWeight: t2ep6.backwardWeight,
			center: t2ep6.center,
			forward: t2ep6.forward,
			forwardWeight: t2ep6.forwardWeight,
			trackBank: 45,
		};
		const t2aep7 = {	// Left extent of curve
			backwardWeight: t2ep7.backwardWeight,
			center: t2ep7.center,
			forward: t2ep7.forward,
			forwardWeight: t2ep7.forwardWeight,
			trackBank: 45,
		};
		const t2aep8 = {	// End of curve
			backwardWeight: t2ep8.backwardWeight,
			center: t2ep8.center,
			forward: t2ep8.forward,
			trackBank: 10,
		};

		const t2as2 = {
			points: [ jrep4, t2aep5, t2aep6, t2aep7, t2aep8, t2ep9 ]
		};

		tracks.track2a = {
			segments: [ jrs1, t2as2 ]
		};

		//----------------------------------------------------------------------
		// Track 2b, track 2 but using a spiral section

		const t2bep5 = {	// Start of curve
			center: jrv5,
			forward: jrt5,
		};
		const t2bspiral = {
			type: 'spiral',
			axis: posY,
			center: {
				x: t2bep5.center.x,
				y: t2bep5.center.y,
				z: t2bep5.center.z - jrRadius,
			},
			endsAt: {
				x: t2bep5.center.x - jrRadius,
				y: t2bep5.center.y - 3 * jrDescent / 4,
				z: t2bep5.center.z - jrRadius,
			},
		};
		const t2bep9 = {	// Runout
			type: 'straight',
			length: 2 * jrRadius,
		};

		const t2bs2 = {
			points: [ jrep4, t2bep5, t2bspiral, t2bep9 ]
		};

		tracks.track2b = {
			segments: [ jrs1, t2bs2 ]
		};

		//----------------------------------------------------------------------
		// Track 3, slope into a jump with a turn right looping underneath the jump

		const t3ep5 = {	// Start of curve
			center: jrv5,
			forward: jrt5,
			forwardWeight: circleWeight * jrRadius,
		};
		const t3ep6 = {	// Top of curve
			backwardWeight: circleWeight * jrRadius,
			center: {
				x: t3ep5.center.x - jrRadius,
				y: t3ep5.center.y - jrDescent / 4,
				z: t3ep5.center.z + jrRadius,
			},
			forward: posZ,
			forwardWeight: circleWeight * jrRadius,
		};
		const t3ep7 = {	// Right extent of curve
			backwardWeight: circleWeight * jrRadius,
			center: {
				x: t3ep6.center.x + jrRadius,
				y: t3ep6.center.y - jrDescent / 4,
				z: t3ep6.center.z + jrRadius
			},
			forward: posX,
			forwardWeight: circleWeight * jrRadius,
		};
		const t3ep8 = {	// End of curve
			backwardWeight: circleWeight * jrRadius,
			center: {
				x: t3ep7.center.x + jrRadius,
				y: t3ep7.center.y - jrDescent / 4,
				z: t3ep7.center.z - jrRadius
			},
			forward: negZ,
		};
		const t3ep9 = {	// Runout
			type: 'straight',
			length: 2 * jrRadius,
		};

		const t3s2 = {
			points: [ jrep4, t3ep5, t3ep6, t3ep7, t3ep8, t3ep9 ]
		};

		tracks.track3 = {
			segments: [ jrs1, t3s2 ]
		};

		//----------------------------------------------------------------------
		// Track 3a, track 3 with bank

		const t3aep5 = {	// Start of curve
			center: t3ep5.center,
			forward: t3ep5.forward,
			forwardWeight: t3ep5.forwardWeight,
			trackBank: -10,
		};
		const t3aep6 = {	// Top of curve
			backwardWeight: t3ep6.backwardWeight,
			center: t3ep6.center,
			forward: t3ep6.forward,
			forwardWeight: t3ep6.forwardWeight,
			trackBank: -45,
		};
		const t3aep7 = {	// Right extent of curve
			backwardWeight: t3ep7.backwardWeight,
			center: t3ep7.center,
			forward: t3ep7.forward,
			forwardWeight: t3ep7.forwardWeight,
			trackBank: -45,
		};
		const t3aep8 = {	// End of curve
			backwardWeight: t3ep8.backwardWeight,
			center: t3ep8.center,
			forward: t3ep8.forward,
			trackBank: -10,
		};

		const t3as2 = {
			points: [ jrep4, t3aep5, t3aep6, t3aep7, t3aep8, t3ep9 ]
		};

		tracks.track3a = {
			segments: [ jrs1, t3as2 ]
		};

		//----------------------------------------------------------------------
		// Track 4, slope into a loop

		// See https://spencermortensen.com/articles/bezier-circle/
		// If we want a closer approximation, we would need to break the
		// convention that backward = -forward and allow backward to be
		// forward rotated 180 degrees around down.

		const t4loopRadius = 3;
		const t4loopOffset = .4;
		const t4loopWeight = circleWeight * t4loopRadius;

		const t4ep3 = {	// End of slope, start of flat
			center: zero,
			forward: negX,
			backwardWeight: 4,
		};
		const t4ep4 = {	// Entry into loop
			center: {
				x: t4ep3.center.x - t4loopRadius,
				y: t4ep3.center.y,
				z: t4ep3.center.z
			},
			forward: negX,
			forwardWeight: t4loopWeight,
		};
		const t4ep5 = {	// First quarter of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep4.center.x - t4loopRadius,
				y: t4ep4.center.y + t4loopRadius,
				z: t4ep4.center.z + t4loopOffset
			},
			forward: posY,	// This should have a small z-component
			forwardWeight: t4loopWeight,
			trackBank: negX,
		};
		const t4ep6 = {	// Top of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep5.center.x + t4loopRadius,
				y: t4ep5.center.y + t4loopRadius,
				z: t4ep5.center.z + t4loopOffset
			},
			forward: posX,	// This should have a small z-component
			forwardWeight: t4loopWeight,
			trackBank: posY,
		};
		const t4ep7 = {	// Last quarter of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep6.center.x + t4loopRadius,
				y: t4ep6.center.y - t4loopRadius,
				z: t4ep6.center.z + t4loopOffset
			},
			forward: negY,	// This should have a small z-component
			forwardWeight: t4loopWeight,
			trackBank: posX,
		};
		const t4ep8 = {	// Exit of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep7.center.x - t4loopRadius,
				y: t4ep7.center.y - t4loopRadius,
				z: t4ep7.center.z + t4loopOffset
			},
			forward: negX,
		};
		const t4ep9 = {	// Runout
			type: 'straight',
			length: 2 * t4loopRadius,
		};

		const t4s1 = {
			points: [ lep1, lep2, t4ep3, t4ep4, t4ep5, t4ep6, t4ep7, t4ep8, t4ep9 ]
		};

		tracks.track4 = {
			segments: [ t4s1 ]
		};

		//----------------------------------------------------------------------
		// Track 5, flat 180 degree turns

		const t5radius = 4;
		const t5weight = t5radius * circleWeight;
		const t5rightHeight = 2;
		const t5center = { x:0, y:0, z:0 };
		const t5runout = 1;
		
		const t5ep0L = {
			center: {
				x: t5center.x - t5runout,
				y: 0,
				z: t5center.z + t5radius
			},
			forward: posX,
		};
		
		const t5ep1L = {
			center: {
				x: t5center.x,
				y: 0,
				z: t5center.z + t5radius
			},
			forward: posX,
			forwardWeight: t5weight,
		}
		
		const t5ep2L = {
			backwardWeight: t5weight,
			center: {
				x: t5center.x + t5radius,
				y: 0,
				z: t5center.z,
			},
			forward: negZ,
			forwardWeight: t5weight,
		}
		
		const t5ep3L = {
			backwardWeight: t5weight,
			center: {
				x: t5center.x,
				y: 0,
				z: t5center.z - t5radius,
			},
			forward: negX,
		}
		
		const t5ep0R = {
			center: {
				x: t5center.x - t5runout,
				y: t5rightHeight,
				z: t5center.z - t5radius
			},
			forward: posX,
		};
		
		const t5ep1R = {
			center: {
				x: t5center.x,
				y: t5rightHeight,
				z: t5center.z - t5radius
			},
			forward: posX,
			forwardWeight: t5weight,
		}
		
		const t5ep2R = {
			backwardWeight: t5weight,
			center: {
				x: t5center.x + t5radius,
				y: t5rightHeight,
				z: t5center.z,
			},
			forward: posZ,
			forwardWeight: t5weight,
		}
		
		const t5ep3R = {
			backwardWeight: t5weight,
			center: {
				x: t5center.x,
				y: t5rightHeight,
				z: t5center.z + t5radius,
			},
			forward: negX,
		}
		
		const t5runoutStraight = {
			type: 'straight',
			length: t5runout,
		}
		
		tracks.track5 = {
			segments: [
				{
					points: [ t5ep0L, t5ep1L, t5ep2L, t5ep3L, t5runoutStraight ],
				},
				{
					points: [ t5ep0R, t5ep1R, t5ep2R, t5ep3R, t5runoutStraight ],
				},
			]
		};

		//----------------------------------------------------------------------
		// Track 5a, track 5 using spiral
		
		const t5acurveL = {
			type: 'spiral',
			axis: negY,
			center: t5center,
			endsAt: {
				x: t5ep3L.center.x,
				y: t5rightHeight,
				z: t5ep3L.center.z,
			},
		};
		
		const t5aep0L = {
			center: {
				x: t5center.x - t5runout,
				y: t5rightHeight,
				z: t5center.z + t5radius
			},
			forward: posX,
		};
		
		const t5aep0R = {
			center: {
				x: t5center.x - t5runout,
				y: 2 * t5rightHeight,
				z: t5center.z - t5radius
			},
			forward: posX,
		};
		
		const t5acurveR = {
			type: 'spiral',
			axis: negY,
			center: t5center,
			endsAt: {
				x: t5ep3R.center.x,
				y: 2 * t5rightHeight,
				z: t5ep3R.center.z,
			},
		};
		
		tracks.track5a = {
			segments: [
				{
					points: [ t5ep0L, t5ep1L, t5ep2L, t5ep3L, t5runoutStraight ],
				},
				{
					points: [ t5aep0L, t5runoutStraight, t5acurveL, t5runoutStraight ],
				},
				{
					points: [ t5aep0R, t5runoutStraight, t5acurveR, t5runoutStraight ],
				},
			]
		};

		//======================================================================
		// BABYLON IMPLEMENTATION

		const canvas = document.getElementById("renderCanvas");

		const startRenderLoop = function (engine, canvas) {
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					sceneToRender.render();
				}
			});
		}

		//	It is not clear why 'engine' and 'scene' must be declared as 'var'
		//	instead of 'let'. The page throws a 'engine is null' exception if
		//	'engine' is declared 'let' and does not display anything if 'scene'
		//	is declared 'let', presumably becasue 'scene' is null when
		//	sceneToRender is set.
		var engine = null;
		var scene = null;
		let sceneToRender = null;
		const trackMeshes = [];

		const createDefaultEngine = function() {
			return new BABYLON.Engine(canvas, true, {
				preserveDrawingBuffer: true,
				stencil: true,
				disableWebGL2Support: false
			});
		};

		const createScene = function () {
			const scene = new BABYLON.Scene(engine);

			const camera = new BABYLON.ArcRotateCamera(
				"Camera",
				3 * Math.PI / 2,
				3 * Math.PI / 8,
				30,
				BABYLON.Vector3.Zero());
			camera.attachControl(canvas, true);
			const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 50, 0));

			scene.enablePhysics(new BABYLON.Vector3(0, -8.91, 0), new BABYLON.AmmoJSPlugin());

			return scene;
		}

		const createMesh = function() {

			for (let mesh of trackMeshes) {
				scene.removeMesh(mesh);
				mesh.dispose();
			}
			trackMeshes.length = 0;

			const track = tracks[trackSelector.value];
			let settings = options[trackSelector.value];
			if (settings === null || settings === undefined) settings = {};

			const ribbons = TrackPOC.build(track, (u) => { return new BABYLON.Vector3(u.x, u.y, u.z); }, settings);
			for (let i = 0; i < ribbons.length; i++) {
				const trackMesh = BABYLON.MeshBuilder.CreateRibbon(
						`Segment${i}`,
						{
							pathArray: ribbons[i],
							sideOrientation: BABYLON.Mesh.DOUBLESIDE,
							closePath: track.closed,
						},
						scene);
				trackMesh.physicsImpostor = new BABYLON.PhysicsImpostor(trackMesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0 }, scene);
				trackMeshes.push(trackMesh);
			}
		}

		const drawLine = function(points, color) {
			const options = {
				colors: [],
				points: points,
			}
			for (let i = 0; i < points.length; i++) { options.colors.push(green); }
			BABYLON.MeshBuilder.CreateLines("lines", options);
		}

		window.initFunction = async function() {

			const asyncEngineCreation = async function() {
				try {
					return createDefaultEngine();
				} catch(e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			if (!engine) throw 'engine should not be null.';

			await Ammo();

			startRenderLoop(engine, canvas);

			window.scene = createScene();
			createMesh();
		};

		initFunction().then(() => {
			sceneToRender = scene
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});

		// testing on track 2
		const ballDiameter = .25;
		const ballWeight = 2;
		let ball;
		const dropTheBall = () => {

			if (ball) scene.removeMesh(ball);
			ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: ballDiameter }, scene);
			ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, {mass: ballWeight}, scene);

			const track = tracks[trackSelector.value];
			const segment = track.segments[0];
			const p0 = segment.points[0].center;
			const p1 = segment.points[1].center;

			const t = .8;
			const olt = 1 - t;
			const altitude = 1;
			ball.position.x = p0.x * t + p1.x * olt;
			ball.position.y = p0.y * t + p0.y * olt + altitude;	// Force the ball above the track
			ball.position.z = p0.z * t + p1.z * olt;
		};

		document.getElementById('go').addEventListener('click', dropTheBall);

	</script>
</body>
</html>
