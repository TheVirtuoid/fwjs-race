<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Babylon.js sample code</title>

		<!-- Babylon.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<!-- Virtuoid -->
		<script src="/js/track-poc.js"></script>

		<style>
			html, body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
		</style>
	</head>
<body>
	<div>
		<label for="tracks">Choose a track:</label>
		<select name="tracks" id="tracks">
			<option value="track0">Track 0 (closed oval)</option>
			<option value="track1">Track 1 (single ramp)</option>
			<option value="track2">Track 2 (ramp with jump and left curve)</option>
			<option value="track3">Track 3 (ramp with jump and right curve)</option>
		</select>
	</div>
	<div>
		<canvas id="renderCanvas"></canvas>
	</div>
	<script>
	
		//======================================================================
		// TRACK SELECTION
		const trackSelector = document.getElementById("tracks");
		trackSelector.addEventListener("change", () => {
			createMesh();
		});

		//======================================================================
		// TRACK DEFINITIONS
		
		// Nomenclature
		//
		// All track variables start with 'tm' denoting 'track #m'.
		//
		// A one or two letter abbreviate follows describing the type of
		// The table below defines these. These are defined in relationship to
		// one or a series of end points.
		//
		// A reference to a single end point uses the letter 'n'.
		//
		// A reference to a range of end points uses the form 'n_o' which
		// refers to the end points n, n+1, ... o.
		//
		//	c	tmcn	a Bezier curve end point's center vector
		//	ep	tmepn	a Bezier curve end point
		//	s	tmsn_o	a segment (Bezier cubic curve)
		//	t	tmtn_o	a tangent
		
		const tracks = {};
		const options = {};
		
		//----------------------------------------------------------------------
		// Track 0, the original demo track
		const posX = new BABYLON.Vector3.Right;
		const negX = new BABYLON.Vector3.Left;
		const posZ = new BABYLON.Vector3.Forward;
		const negZ = new BABYLON.Vector3.Backward;
		const up = new BABYLON.Vector3.Up;
		const zero = { x:0, y:0, z:0 };

		const trackWidth = 0.5;
		const cpDistance = 0.5;		// This is now the forward/backward weight
		const segmentation = 6;		// Obsolete. The new system uses 'precision'.
		
		const t0ds = {
			backwardWeight: cpDistance,
			forwardWeight: cpDistance,
			trackWidth: trackWidth,
		};

		const centerLine = [
			{ center: new BABYLON.Vector3(2, 0, 0), forward: posZ },	// Start position
			{ center: new BABYLON.Vector3(2, 0, 4), forward: posZ },
			{ center: new BABYLON.Vector3(0, 0, 6), forward: negX },
			{ center: new BABYLON.Vector3(-2, 0, 4), forward: negZ },
			{ center: new BABYLON.Vector3(-2, 0, -4), forward: negZ },
			{ center: new BABYLON.Vector3(0, 0, -6), forward: posX },
			{ center: new BABYLON.Vector3(2, 0, -4), forward: posZ },
		];
		
		// Note that the original implementation used 'closePath: true' when
		// creating the ribbon. The system does not do this so we manually
		// close the track by adding an extra segment.
		const t0s1 = {
			points: centerLine
		}
		
		const t0s2 = {
			points: [ centerLine[centerLine.length - 1], centerLine[0] ]
		}
		
		tracks.track0 = {
			segments: [ t0s1, t0s2 ]
		}
		options.track0 = t0ds;
		
		//----------------------------------------------------------------------
		// Track 1, a simple slope
		const t1v1 = { x:10 , y:5, z:0 };
		const t1v2 = { x:9, y:4.9, z:0 };
		const t1t1_2 = TrackPOC.vector.direction(t1v1, t1v2);
		const t1ep1 = {	// Start of starting ramp
			center: t1v1,
			forward: t1t1_2,
		};
		const t1ep2 = {	// End of starting ramp, start of runout
			center: t1v2,
			forward: t1t1_2,
			forwardWeight: 1.1,
		};
		const t1ep3 = {	// End of slope, start of runout
			center: zero,
			forward: negX,
			backwardWeight: 4,
		};
		const t1ep4 = {	// End of runout flat
			center: { x:-2, y:0, z:0 },
			forward: negX,
		};
		
		const t1s1 = {
			points: [ t1ep1, t1ep2, t1ep3, t1ep4 ]
		};
		
		tracks.track1 = {
			segments: [ t1s1 ]
		};
		
		//----------------------------------------------------------------------
		// Track 2, slope into a jump with a turn left looping underneath the jump
		
		// NOTE: This may need some adjustments on the curve to avoid bumps where
		// we specify the tangent to have no y component.
		
		const t2v1 = { x:10 , y:5, z:0 };
		const t2v2 = { x:9, y:4.9, z:0 };
		const t2t1_2 = TrackPOC.vector.direction(t1v1, t1v2);
		const t2ep1 = {	// Start of starting ramp
			center: t2v1,
			forward: t2t1_2,
		};
		const t2ep2 = {	// End of starting ramp, start of runout
			center: t2v2,
			forward: t2t1_2,
			forwardWeight: 1.1,
		};
		const t2ep3 = {	// End of slope, start of runout
			center: { x:.5, y:1, z:0 },
			forward: negX,
			backwardWeight: 4,
		};
		const t2ep4 = {	// Start of catch
			center: { x:-.5, y:.9, z:0 },
			forward: negX,
		};
		const t2ep5 = {	// Start of curve
			center: { x:-1.5, y:.8, z:0 },
			forward: negX,
		};
		const t2ep6 = {	// Top of curve
			center: { x:-3, y:.7, z:-1.5 },
			forward: negZ,
		};
		const t2ep7 = {	// Left extent of curve
			center: { x:-1.5, y:.6, z:-3 },
			forward: posX,
		};
		const t2ep8 = {	// End of curve
			center: { x:0, y:.5, z:-1.5 },
			forward: posZ,
		};
		const t2ep9 = {	// Runout
			center: { x:0, y:0, z:2 },
			forward: posZ,
		};
		
		const t2s1 = {
			points: [ t2ep1, t2ep2, t2ep3 ]
		};
		const t2s2 = {
			points: [ t2ep4, t2ep5, t2ep6, t2ep7, t2ep8, t2ep9 ]
		};
		
		tracks.track2 = {
			segments: [ t2s1, t2s2 ]
		};
		
		//----------------------------------------------------------------------
		// Track 2a, track 2 with bank
		
		//----------------------------------------------------------------------
		// Track 3, slope into a jump with a turn right looping underneath the jump

		const t3v1 = { x:10 , y:5, z:0 };
		const t3v2 = { x:9, y:4.9, z:0 };
		const t3t1_2 = TrackPOC.vector.direction(t1v1, t1v2);
		const t3ep1 = {	// Start of starting ramp
			center: t3v1,
			forward: t3t1_2,
		};
		const t3ep2 = {	// End of starting ramp, start of runout
			center: t3v2,
			forward: t3t1_2,
			forwardWeight: 1.1,
		};
		const t3ep3 = {	// End of slope, start of runout
			center: { x:.5, y:1, z:0 },
			forward: negX,
			backwardWeight: 4,
		};
		const t3ep4 = {	// Start of catch
			center: { x:-.5, y:.9, z:0 },
			forward: negX,
		};
		const t3ep5 = {	// Start of curve
			center: { x:-1.5, y:.8, z:0 },
			forward: negX,
		};
		const t3ep6 = {	// Top of curve
			center: { x:-3, y:.7, z:1.5 },
			forward: posZ,
		};
		const t3ep7 = {	// Right extent of curve
			center: { x:-1.5, y:.6, z:3 },
			forward: posX,
		};
		const t3ep8 = {	// End of curve
			center: { x:0, y:.5, z:1.5 },
			forward: negZ,
		};
		const t3ep9 = {	// Runout
			center: { x:0, y:0, z:-2 },
			forward: negZ,
		};
		
		const t3s1 = {
			points: [ t3ep1, t3ep2, t3ep3 ]
		};
		const t3s2 = {
			points: [ t3ep4, t3ep5, t3ep6, t3ep7, t3ep8, t3ep9 ]
		};
		
		tracks.track3 = {
			segments: [ t3s1, t3s2 ]
		};
		
		//----------------------------------------------------------------------
		// Track 3a, track 3 with bank
		
		//----------------------------------------------------------------------
		// Track 4, slope into a loop
		
		//======================================================================
		// BABYLON IMPLEMENTATION

		const canvas = document.getElementById("renderCanvas");

		const startRenderLoop = function (engine, canvas) {
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					sceneToRender.render();
				}
			});
		}

		//	It is not clear why 'engine' and 'scene' must be declared as 'var'
		//	instead of 'let'. The page throws a 'engine is null' exception if
		//	'engine' is declared 'let' and does not display anything if 'scene'
		//	is declared 'let', presumably becasue 'scene' is null when
		//	sceneToRender is set.
		var engine = null;
		var scene = null;
		let sceneToRender = null;
		const trackMeshes = [];
		
		const createDefaultEngine = function() {
			return new BABYLON.Engine(canvas, true, {
				preserveDrawingBuffer: true,
				stencil: true,
				disableWebGL2Support: false
			});
		};
		
		const createScene = function (track, settings = {}) {
			const scene = new BABYLON.Scene(engine);

			const camera = new BABYLON.ArcRotateCamera(
				"Camera",
				3 * Math.PI / 2,
				3 * Math.PI / 8,
				30,
				BABYLON.Vector3.Zero());
			camera.attachControl(canvas, true);
			const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 50, 0));

			return scene;
		}
		
		const createMesh = function() {
		
			for (let mesh of trackMeshes) {
				scene.removeMesh(mesh);
			}
			trackMeshes.length = 0;
			
			const track = tracks[trackSelector.value];
			let settings = options[trackSelector.value];
			if (settings === null || settings === undefined) settings = {};
			
			const ribbons = TrackPOC.build(track, (u) => { return new BABYLON.Vector3(u.x, u.y, u.z); }, settings);
			for (let i = 0; i < ribbons.length; i++) {
				trackMeshes.push(BABYLON.MeshBuilder.CreateRibbon(
					`Segment${i}`,
					{
						pathArray: ribbons[i],
						sideOrientation: BABYLON.Mesh.DOUBLESIDE
					},
					scene));
			}
			
			/*
			drawBigAxes();
			
			for (let s of track.segments) {
				for (let p of s.points) {
					drawAxes(p.center);
				}
			}
			
			drawLine(ribbons[0][1], green);
			*/
		}
		
		const red = new BABYLON.Color4(1, 0, 0);
		const green = new BABYLON.Color4(0, 1, 0);
		const blue = new BABYLON.Color4(0, 0, 1);
		
		const drawAxes = function(u) {
			const options = {
				points: [ new BABYLON.Vector3(u.x, u.y, u.z), new BABYLON.Vector3(u.x, u.y, u.z) ],
				colors: [ red, red ]
			}
			options.points[1].x += 1;
			BABYLON.MeshBuilder.CreateLines("lines", options);
			options.colors = [ green, green ];
			options.points[1].x -= 1;
			options.points[1].y += 1;
			BABYLON.MeshBuilder.CreateLines("lines", options);
			options.colors = [ blue, blue ];
			options.points[1].y -= 1;
			options.points[1].z += 1;
			BABYLON.MeshBuilder.CreateLines("lines", options);
		}
		
		const drawBigAxes = function(u) {
			const options = {
				points: [ new BABYLON.Vector3(-50, 0, 0), new BABYLON.Vector3(50, 0, 0) ],
			}
			BABYLON.MeshBuilder.CreateDashedLines("lines", options).color = red;
			options.points = [ new BABYLON.Vector3(0, -50, 0), new BABYLON.Vector3(0, 50, 0) ];
			BABYLON.MeshBuilder.CreateDashedLines("lines", options).color = green;
			options.points = [ new BABYLON.Vector3(0, 0, -50), new BABYLON.Vector3(0, 0, 50) ];
			BABYLON.MeshBuilder.CreateDashedLines("lines", options).color = blue;
		}
		
		const drawLine = function(points, color) {
			const options = {
				colors: [],
				points: points,
			}
			for (let i = 0; i < points.length; i++) { options.colors.push(green); }
			BABYLON.MeshBuilder.CreateLines("lines", options);
		}

		window.initFunction = async function() {

			const asyncEngineCreation = async function() {
				try {
					return createDefaultEngine();
				} catch(e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			if (!engine) throw 'engine should not be null.';

			startRenderLoop(engine, canvas);
			
			// CHANGE TRACK HERE
			window.scene = createScene(tracks[trackSelector.value]);
			createMesh();
		};
		
		initFunction().then(() => {
			sceneToRender = scene
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>
</html>
