<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Fun with JavaScript - Track POC</title>

		<!-- Babylon.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
<!--
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
-->
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<!-- Virtuoid -->
		<script src="/js/track-poc.js"></script>

		<style>
			html, body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
		</style>
	</head>
<body>
	<div>
		<label for="tracks">Choose a track:</label>
		<select name="tracks" id="tracks">
			<option value="track4">Track 4 (loop)</option>
			<option value="track5">Track 5 (flat 180&#176; turns)</option>
			<option value="track5a">Track 5a (track 5 using spiral)</option>
			<option value="track6a">Track 6a (left helix, no center)</option>
			<option value="track6b">Track 6b (left helix, center)</option>
			<option value="track6c">Track 6c (right helix, no center)</option>
			<option value="track6d">Track 6d (right helix, center)</option>
		</select>
		<select id="trackFamilies"></select>
		<select id="trackMembers"></select>
		<button type="button" id="go">GO!</button>
	</div>
	<div>
		<canvas id="renderCanvas"></canvas>
	</div>
	<script>


		//======================================================================
		// TRACK SELECTION

		const trackSelector = document.getElementById("tracks");
		const familySelector = document.getElementById("trackFamilies");
		const memberSelector = document.getElementById("trackMembers");

		trackSelector.addEventListener("change", () => {
			createMesh(trackSelector);
		});
		familySelector.addEventListener("change", () => {
			tracks.onFamilyChanged();
		});
		memberSelector.addEventListener("change", () => {
			createMesh(memberSelector);
		});

		//======================================================================
		// TRACK DEFINITIONS

		const posX = new BABYLON.Vector3.Right;
		const negX = new BABYLON.Vector3.Left;
		const posY = new BABYLON.Vector3.Up;
		const negY = new BABYLON.Vector3.Down;
		const posZ = new BABYLON.Vector3.Forward;
		const negZ = new BABYLON.Vector3.Backward;
		const zero = { x:0, y:0, z:0 };

		const tracks = {
			onFamilyChanged: function() {
				const key = familySelector.value;
				for (let option of memberSelector.children) {
					const familyKey = option.getAttribute("family");
					option.style.display = familyKey === key ? "block" : "none";
				}
			},
			register: function(track) {

				// Invoke function if not an object
				if (typeof(track) === 'function') track = track();

				// Perform late initialization
				if (track.init) track.init();

				// Get the family
				if (!track.family && !track.sibling) throw "A track must define either 'family' or 'sibling'";
				if ((track.family || track.sibling) && (track.name || track.desc)) throw "A track defining 'family' or 'sibling' cannot define 'name' or 'desc'";
				if (track.sibling && !track.sibling.family) throw `A 'sibling' track, here '${track.sibling}', must define 'family'`;
				const family = track.family ? track.family : track.sibling.family;
				const familyKey = this._removeSpaces(family);

				// Get the member
				if (track.sibling && !track.member) throw "A track defining 'sibling' must also define 'member'";
				if (track.sibling && track.member && track.member === this._originalMember) {
					throw `A track defining 'sibling' cannot have 'member' set to '${this._originalMember}'`;
				}
				const member = track.member ? track.member : this._originalMember;
				const memberKey = familyKey + this._removeSpaces(member);

				// Old track selector
				const key = familyKey + memberKey;
				const tsOption = document.createElement("option");
				tsOption.setAttribute('value', key);
				tsOption.innerHTML = family + ' (' + member + ')';
				trackSelector.appendChild(tsOption);

				// Add family if necessary
				if (!this._families[familyKey]) {
					// This possibly leads to multiple member lists to avoid
					// altering the 'display' style in onFamilyChanged
					this._families[familyKey] = [];

					// Add the family to the family list
					const fsOption = document.createElement("option");
					fsOption.setAttribute('value', familyKey);
					fsOption.innerHTML = family;
					familySelector.appendChild(fsOption);
				}

				// Add to member selector
				const msOption = document.createElement("option");
				msOption.setAttribute('value', key);
				msOption.setAttribute('family', familyKey);
				msOption.innerHTML = member;
				memberSelector.appendChild(msOption);

				// Add the track to the tracks and options arrays
				this._tracks[key] = track.track;
				if (track.options) this._options[key] = track.options;
			},

			_families: {},
			_options: {},
			_originalMember: 'Original',
			_removeSpaces: function(value) { return value.replace(/\s/g, ''); },
			_tracks: {},
		};

		// See https://spencermortensen.com/articles/bezier-circle/
		// If we want a closer approximation, we would need to break the
		// convention that backward = -forward and allow backward to be
		// forward rotated 180 degrees around down.
		const circleWeight = 0.5519150244935105707435627;

		//----------------------------------------------------------------------
		// Closed ovals

		const track0 = {
			family: 'Closed oval',
			points: [
				{ center: new BABYLON.Vector3(2, 0, 0), forward: posZ },	// Start position
				{ center: new BABYLON.Vector3(2, 0, 4), forward: posZ },
				{ center: new BABYLON.Vector3(0, 0, 6), forward: negX },
				{ center: new BABYLON.Vector3(-2, 0, 4), forward: negZ },
				{ center: new BABYLON.Vector3(-2, 0, -4), forward: negZ },
				{ center: new BABYLON.Vector3(0, 0, -6), forward: posX },
				{ center: new BABYLON.Vector3(2, 0, -4), forward: posZ },
			],
			track: { closed: true },
			options: {
				backwardWeight: 0.5,
				forwardWeight: 0.5,
				trackWidth: 0.5,
			},
			init: function() {
				this.track.segments = [ { points: this.points } ];
			}
		}
		tracks.register(track0);
		tracks.register({
			sibling: track0,
			member: 'Variable wall height',
			options: track0.options,
			track: {
				closed: true,
				segments: [
					{
						points: [
							track0.points[0],
							{ center: track0.points[1].center, forward: track0.points[1].forward, wallHeight: .6 },
							{ center: track0.points[2].center, forward: track0.points[2].forward, wallHeight: .7 },
							{ center: track0.points[3].center, forward: track0.points[3].forward, wallHeight: .6 },
							track0.points[4],
							track0.points[5],
							track0.points[6],
						],
					},
				],
			},
		});

		//----------------------------------------------------------------------
		// Common launch and jump points

		const launch = {
			points: [
				{ x:10 , y:5, z:0 },
				{ x:9, y:4.9, z:0 },
			],

			init: function() {
				this.forward = { x:-1, y:-0.1, z:0 };
				this.start = {
					center: launch.points[0],
					forward: launch.forward,
				};
				this.straight = {
					type: 'straight',
					endsAt: launch.points[1],
					startsAt: launch.points[0],
					forwardWeight: 1.1
				};
			}
		}
		launch.init();

		const jump = {
			descent: 1,
			launchSegment: {
				points: [
					launch.straight,
					{
						center: { x:.5, y:1, z:0 },
						forward: negX,
						backwardWeight: 4,
					},
				],
			},
			radius: 2,

			_catchDrop: .1,
			_gap: 1,

			init: function() {
				const launchEnd = this.launchSegment.points[this.launchSegment.points.length - 1];
				this.catchStart = {
					center: {
						x: launchEnd.center.x - this._gap,
						y: launchEnd.center.y - this._catchDrop,
						z: launchEnd.center.z,
					},
					forward: negX,
				}
				this.catchEnd = {
					center: {
						x: this.catchStart.center.x - this.radius + this._gap / 2,
						y: this.catchStart.center.y - this.descent / 4,
						z: this.catchStart.center.z
					},
					forward: negX,
				}
				this.runout = {
					type: 'straight',
					length: 2 * this.radius,
				}
			},
		}
		jump.init();

		const parametricBank = [
			{ t:0, v:10 },
			{ t:1/3, v:23 },
			{ t:2/3, v:23 },
			{ t:1, v:10 },
		]

		//----------------------------------------------------------------------
		// Simple slope

		const track1 = {
			family: "Simple slope",
			runoutStart: {
				center: zero,
				forward: negX,
				backwardWeight: 4,
			},
			runoutStraight: {
				type: 'straight',
				length: 2,
			},

			init: function() {
				this.track = {
					segments: [
						{
							points: [
								launch.start,
								{
									type: 'straight',
									endsAt: launch.points[1],
									forwardWeight: 1.1
								},
								this.runoutStart,
								this.runoutStraight,
							],
						}
					],
				};
			}
		}
		tracks.register(track1);
		const track1a = {
			sibling: track1,
			member: 'Variable track width',
			runoutStraight: {
				type: 'straight',
				length: track1.runoutStraight.length,
				trackWidth: 2,
			},

			init: function() {
				this.track = {
					segments: [
						{
							points: [
								launch.start,
								launch.straight,
								track1.runoutStart,
								this.runoutStraight,
							],
						},
					],
				}
			},
		}
		tracks.register(track1a);
		tracks.register({
			sibling: track1,
			member: "Alternate straight",
			track: {
				segments: [
					{
						points: [
							{
								type: 'straight',
								startsAt: launch.points[0],
								forward: launch.forward,
								length: 1.004987562112089,
								forwardWeight: 1.1
							},
							track1.runoutStart,
							track1a.runoutStraight,
						],
					},
				],
			},
		});

		//----------------------------------------------------------------------
		// Left turn ramp

		const track2 = {
			family: "Left turn ramp",

			curveEnd: {
				backwardWeight: circleWeight * jump.radius,
				forward: posZ,
			},
			curveLeft: {
				backwardWeight: circleWeight * jump.radius,
				forward: posX,
				forwardWeight: circleWeight * jump.radius,
			},
			curveStart: {
				center: jump.catchEnd.center,
				forward: jump.catchEnd.forward,
				forwardWeight: circleWeight * jump.radius,
			},
			curveTop: {
				backwardWeight: circleWeight * jump.radius,
				forward: negZ,
				forwardWeight: circleWeight * jump.radius,
			},

			init: function() {
				this.curveTop.center = {
					x: this.curveStart.center.x - jump.radius,
					y: this.curveStart.center.y - jump.descent / 4,
					z: this.curveStart.center.z - jump.radius,
				}
				this.curveLeft.center = {
					x: this.curveTop.center.x + jump.radius,
					y: this.curveTop.center.y - jump.descent / 4,
					z: this.curveTop.center.z - jump.radius
				}
				this.curveEnd.center = {
					x: this.curveLeft.center.x + jump.radius,
					y: this.curveLeft.center.y - jump.descent / 4,
					z: this.curveLeft.center.z + jump.radius
				}
				this.track = {
					segments: [
						jump.launchSegment,
						{
							points: [
								jump.catchStart,
								this.curveStart,
								this.curveTop,
								this.curveLeft,
								this.curveEnd,
								jump.runout,
							],
						},
					],
				}
			},
		}
		tracks.register(track2);
		tracks.register({
			sibling: track2,
			member: "45&#176; bank",
			track: {
				segments: [ jump.launchSegment, {
					points: [
						jump.catchStart,
						{
							center: track2.curveStart.center,
							forward: track2.curveStart.forward,
							forwardWeight: track2.curveStart.forwardWeight,
							trackBank: 10,
						},
						{
							backwardWeight: track2.curveTop.backwardWeight,
							center: track2.curveTop.center,
							forward: track2.curveTop.forward,
							forwardWeight: track2.curveTop.forwardWeight,
							trackBank: 45,
						},
						{
							backwardWeight: track2.curveLeft.backwardWeight,
							center: track2.curveLeft.center,
							forward: track2.curveLeft.forward,
							forwardWeight: track2.curveLeft.forwardWeight,
							trackBank: 45,
						},
						{
							backwardWeight: track2.curveEnd.backwardWeight,
							center: track2.curveEnd.center,
							forward: track2.curveEnd.forward,
							trackBank: 10,
						},
						jump.runout
					],
				}],
			},
		});
		tracks.register({
			sibling: track2,
			member: "Using spiral",
			track: {
				segments: [ jump.launchSegment, {
					points: [
						jump.catchStart,
						jump.catchEnd,
						{
							type: 'spiral',
							endsAt: {
								center: track2.curveEnd.center,
								forward: track2.curveEnd.forward,
							},
							rotate: 'left',
						},
						jump.runout
					],
				}],
			},
		});
		tracks.register({
			sibling: track2,
			member: "Using spiral with 23&#176; bank",
			track: {
				segments: [ jump.launchSegment, {
					points: [
						jump.catchStart,
						jump.catchEnd,
						{
							type: 'spiral',
							endsAt: {
								center: track2.curveEnd.center,
								forward: track2.curveEnd.forward,
							},
							rotate: 'left',
							trackBank: parametricBank,
						},
						jump.runout
					],
				}],
			},
		});

		//----------------------------------------------------------------------
		// Right turn ramp

		const track3 = {
			family: "Right turn ramp",

			curveEnd: {
				backwardWeight: circleWeight * jump.radius,
				forward: negZ,
			},
			curveRight: {
				backwardWeight: circleWeight * jump.radius,
				forward: posX,
				forwardWeight: circleWeight * jump.radius,
			},
			curveStart: track2.curveStart,
			curveTop: {
				backwardWeight: circleWeight * jump.radius,
				forward: posZ,
				forwardWeight: circleWeight * jump.radius,
			},

			init: function() {
				this.curveTop.center = {
					x: this.curveStart.center.x - jump.radius,
					y: this.curveStart.center.y - jump.descent / 4,
					z: this.curveStart.center.z + jump.radius,
				}
				this.curveRight.center = {
					x: this.curveTop.center.x + jump.radius,
					y: this.curveTop.center.y - jump.descent / 4,
					z: this.curveTop.center.z + jump.radius
				}
				this.curveEnd.center = {
					x: this.curveRight.center.x + jump.radius,
					y: this.curveRight.center.y - jump.descent / 4,
					z: this.curveRight.center.z - jump.radius
				}
				this.track = {
					segments: [
						jump.launchSegment,
						{
							points: [
								jump.catchStart,
								this.curveStart,
								this.curveTop,
								this.curveRight,
								this.curveEnd,
								jump.runout,
							],
						},
					],
				}
			},
		}
		tracks.register(track3);
		tracks.register({
			sibling: track3,
			member: "45&#176; bank",
			track: { segments: [
				jump.launchSegment,
				{ points: [
					jump.catchStart,
					{
						center: track3.curveStart.center,
						forward: track3.curveStart.forward,
						forwardWeight: track3.curveStart.forwardWeight,
						trackBank: -10,
					},
					{
						backwardWeight: track3.curveTop.backwardWeight,
						center: track3.curveTop.center,
						forward: track3.curveTop.forward,
						forwardWeight: track3.curveTop.forwardWeight,
						trackBank: -45,
					},
					{
						backwardWeight: track3.curveRight.backwardWeight,
						center: track3.curveRight.center,
						forward: track3.curveRight.forward,
						forwardWeight: track3.curveRight.forwardWeight,
						trackBank: -45,
					},
					{
						backwardWeight: track3.curveEnd.backwardWeight,
						center: track3.curveEnd.center,
						forward: track3.curveEnd.forward,
						trackBank: -10,
					},
					jump.runout
				]},
			]},
		});
		tracks.register({
			sibling: track3,
			member: "Using spiral",
			track: {
				segments: [ jump.launchSegment, {
					points: [
						jump.catchStart,
						jump.catchEnd,
						{
							type: 'spiral',
							endsAt: {
								center: track3.curveEnd.center,
								forward: track3.curveEnd.forward,
							},
							rotate: 'right',
						},
						jump.runout
					],
				}],
			},
		});
		tracks.register({
			sibling: track3,
			member: "Using spiral with 23&#176; bank",
			track: {
				segments: [ jump.launchSegment, {
					points: [
						jump.catchStart,
						jump.catchEnd,
						{
							type: 'spiral',
							endsAt: {
								center: track3.curveEnd.center,
								forward: track3.curveEnd.forward,
							},
							rotate: 'right',
							trackBank: parametricBank,
						},
						jump.runout
					],
				}],
			},
		});

		//----------------------------------------------------------------------
		// Track 4, slope into a loop

		// See https://spencermortensen.com/articles/bezier-circle/
		// If we want a closer approximation, we would need to break the
		// convention that backward = -forward and allow backward to be
		// forward rotated 180 degrees around down.

		const t4loopRadius = 3;
		const t4loopOffset = .4;
		const t4loopWeight = circleWeight * t4loopRadius;

		const t4ep3 = {	// End of slope, start of flat
			center: zero,
			forward: negX,
			backwardWeight: 4,
		};
		const t4ep4 = {	// Entry into loop
			center: {
				x: t4ep3.center.x - t4loopRadius,
				y: t4ep3.center.y,
				z: t4ep3.center.z
			},
			forward: negX,
			forwardWeight: t4loopWeight,
		};
		const t4ep5 = {	// First quarter of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep4.center.x - t4loopRadius,
				y: t4ep4.center.y + t4loopRadius,
				z: t4ep4.center.z + t4loopOffset
			},
			forward: posY,	// This should have a small z-component
			forwardWeight: t4loopWeight,
			trackBank: negX,
		};
		const t4ep6 = {	// Top of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep5.center.x + t4loopRadius,
				y: t4ep5.center.y + t4loopRadius,
				z: t4ep5.center.z + t4loopOffset
			},
			forward: posX,	// This should have a small z-component
			forwardWeight: t4loopWeight,
			trackBank: posY,
		};
		const t4ep7 = {	// Last quarter of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep6.center.x + t4loopRadius,
				y: t4ep6.center.y - t4loopRadius,
				z: t4ep6.center.z + t4loopOffset
			},
			forward: negY,	// This should have a small z-component
			forwardWeight: t4loopWeight,
			trackBank: posX,
		};
		const t4ep8 = {	// Exit of loop
			backwardWeight: t4loopWeight,
			center: {
				x: t4ep7.center.x - t4loopRadius,
				y: t4ep7.center.y - t4loopRadius,
				z: t4ep7.center.z + t4loopOffset
			},
			forward: negX,
		};
		const t4ep9 = {	// Runout
			type: 'straight',
			length: 2 * t4loopRadius,
		};
		const lep2 = {	// End of starting ramp, start of runout
			center: launch.points[1],
			forward: launch.forward,
			forwardWeight: 1.1,
		};

		const t4s1 = {
			points: [ launch.start, lep2, t4ep3, t4ep4, t4ep5, t4ep6, t4ep7, t4ep8, t4ep9 ]
		};

		tracks._tracks.track4 = {
			segments: [ t4s1 ]
		};

		//----------------------------------------------------------------------
		// Track 5, flat 180 degree turns

		const t5radius = 4;
		const t5weight = t5radius * circleWeight;
		const t5Height = [0, 2, 4];
		const t5center = { x:0, y:0, z:0 };
		const t5runout = 1;

		const t5ep0L = {
			center: {
				x: t5center.x + t5radius,
				y: t5center.y + t5Height[0],
				z: t5center.z - t5runout,
			},
			forward: posZ,
		};

		const t5ep1L = {
			center: {
				x: t5ep0L.center.x,
				y: t5ep0L.center.y,
				z: t5ep0L.center.z + t5runout,
			},
			forward: posZ,
			forwardWeight: t5weight,
		}

		const t5ep2L = {
			backwardWeight: t5weight,
			center: {
				x: t5ep1L.center.x - t5radius,
				y: t5ep0L.center.y,
				z: t5ep1L.center.z + t5radius,
			},
			forward: negX,
			forwardWeight: t5weight,
		}

		const t5ep3L = {
			backwardWeight: t5weight,
			center: {
				x: t5ep2L.center.x - t5radius,
				y: t5ep0L.center.y,
				z: t5ep2L.center.z - t5radius,
			},
			forward: negZ,
		}

		const t5ep0R = {
			center: {
				x: t5center.x - t5radius,
				y: t5center.y + t5Height[1],
				z: t5center.z - t5runout,
			},
			forward: posZ,
		};

		const t5ep1R = {
			center: {
				x: t5ep0R.center.x,
				y: t5ep0R.center.y,
				z: t5ep0R.center.z + t5runout,
			},
			forward: posZ,
			forwardWeight: t5weight,
		}

		const t5ep2R = {
			backwardWeight: t5weight,
			center: {
				x: t5ep1R.center.x + t5radius,
				y: t5ep0R.center.y,
				z: t5ep1R.center.z + t5radius,
			},
			forward: posX,
			forwardWeight: t5weight,
		}

		const t5ep3R = {
			backwardWeight: t5weight,
			center: {
				x: t5ep2R.center.x + t5radius,
				y: t5ep0R.center.y,
				z: t5ep2R.center.z - t5radius,
			},
			forward: negZ,
		}

		const t5runoutStraight = {
			type: 'straight',
			length: t5runout,
		}

		tracks._tracks.track5 = {
			segments: [
				{
					points: [ t5ep0L, t5ep1L, t5ep2L, t5ep3L, t5runoutStraight ],
				},
				{
					points: [ t5ep0R, t5ep1R, t5ep2R, t5ep3R, t5runoutStraight ],
				},
			]
		};

		//----------------------------------------------------------------------
		// Track 5a, track 5 using spiral

		const t5aep0L = {
			center: {
				x: t5ep0L.center.x,
				y: t5center.y + t5Height[1],
				z: t5ep0L.center.z,
			},
			forward: t5ep0L.forward,
		};

		const t5acurveL = {
			type: 'spiral',
			endsAt: {
				center: {
					x: t5ep3L.center.x,
					y: t5aep0L.center.y,
					z: t5ep3L.center.z,
				},
				forward: t5ep3L.forward,
			},
			rotate: 'left',
		};

		const t5aep0R = {
			center: {
				x: t5ep0R.center.x,
				y: t5center.y + t5Height[2],
				z: t5ep0R.center.z,
			},
			forward: t5ep0R.forward,
		};

		const t5acurveR = {
			type: 'spiral',
			endsAt: {
				center: {
					x: t5ep3R.center.x,
					y: t5aep0R.center.y,
					z: t5ep3R.center.z,
				},
				forward: t5ep3R.forward,
			},
			rotate: 'right',
		};

		tracks._tracks.track5a = {
			segments: [
				{
					points: [ t5ep0L, t5ep1L, t5ep2L, t5ep3L, t5runoutStraight ],
				},
				{
					points: [ t5aep0L, t5runoutStraight, t5acurveL, t5runoutStraight ],
				},
				{
					points: [ t5aep0R, t5runoutStraight, t5acurveR, t5runoutStraight ],
				},
			]
		};

		// Sort the family and members lists

		//======================================================================
		// BABYLON IMPLEMENTATION

		const canvas = document.getElementById("renderCanvas");

		const startRenderLoop = function (engine, canvas) {
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					sceneToRender.render();
				}
			});
		}

		//	It is not clear why 'engine' and 'scene' must be declared as 'var'
		//	instead of 'let'. The page throws a 'engine is null' exception if
		//	'engine' is declared 'let' and does not display anything if 'scene'
		//	is declared 'let', presumably becasue 'scene' is null when
		//	sceneToRender is set.
		var engine = null;
		var scene = null;
		let sceneToRender = null;
		const trackMeshes = [];

		const createDefaultEngine = function() {
			return new BABYLON.Engine(canvas, true, {
				preserveDrawingBuffer: true,
				stencil: true,
				disableWebGL2Support: false
			});
		};

		const createScene = function () {
			const scene = new BABYLON.Scene(engine);

			const camera = new BABYLON.ArcRotateCamera(
				"Camera",
				3 * Math.PI / 2,
				3 * Math.PI / 8,
				30,
				BABYLON.Vector3.Zero());
			camera.attachControl(canvas, true);
			const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 50, 0));

			scene.enablePhysics(new BABYLON.Vector3(0, -8.91, 0), new BABYLON.AmmoJSPlugin());

			return scene;
		}

		const createMesh = function(selector) {

			for (let mesh of trackMeshes) {
				scene.removeMesh(mesh);
				mesh.dispose();
			}
			trackMeshes.length = 0;

			const key = !selector ? trackSelector.value : selector.value;
			const track = tracks._tracks[key];
			const settings = tracks._options[key] ? tracks._options[key] : {};

			const ribbons = TrackPOC.build(track, (u) => { return new BABYLON.Vector3(u.x, u.y, u.z); }, settings);
			for (let i = 0; i < ribbons.length; i++) {
				const trackMesh = BABYLON.MeshBuilder.CreateRibbon(
						`Segment${i}`,
						{
							pathArray: ribbons[i],
							sideOrientation: BABYLON.Mesh.DOUBLESIDE,
							closePath: track.closed,
						},
						scene);
				trackMesh.physicsImpostor = new BABYLON.PhysicsImpostor(trackMesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0 }, scene);
				trackMeshes.push(trackMesh);
			}
		}

		window.initFunction = async function() {

			const asyncEngineCreation = async function() {
				try {
					return createDefaultEngine();
				} catch(e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			if (!engine) throw 'engine should not be null.';

			await Ammo();

			startRenderLoop(engine, canvas);

			window.scene = createScene();
			tracks.onFamilyChanged();
			createMesh();
		};

		initFunction().then(() => {
			sceneToRender = scene
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});

		// testing on track 2
		const ballDiameter = .25;
		const ballWeight = 2;
		let ball;
		const dropTheBall = () => {

			if (ball) scene.removeMesh(ball);
			ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: ballDiameter }, scene);
			ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, {mass: ballWeight}, scene);

			const track = tracks._tracks[trackSelector.value];
			const segment = track.segments[0];
			const p0 = segment.points[0].center;
			const p1 = segment.points[1].center;

			const t = .8;
			const olt = 1 - t;
			const altitude = 1;
			ball.position.x = p0.x * t + p1.x * olt;
			ball.position.y = p0.y * t + p0.y * olt + altitude;	// Force the ball above the track
			ball.position.z = p0.z * t + p1.z * olt;
		};

		document.getElementById('go').addEventListener('click', dropTheBall);

	</script>
</body>
</html>
